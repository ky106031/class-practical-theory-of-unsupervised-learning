---
title: "教師なし学習実践論（寺口担当分）"
author: "Shunsuke Teraguchi"
output:
  html_document:
    df_print: paged
---

注）この資料は、滋賀大学データサイエンス研究科の教師なし学習の教材です。第三者に公開することのないようお願いします。

# igraphパッケージによるネットワーク解析

-   igraphは代表的なネットワーク解析のパッケージ

-   内部はCで書かれており、高速

-   RとPythonのどちらからも利用可能

```{r}
# install.packages("igraph")
library(igraph)
```

とりあえず、igraphに収録されているグラフデータの例を使って、プロットしてみます。

```{r}
g <- make_graph("Zachary") # Zacharyの空手クラブの友人ネットワーク
plot(g) #実際にはplot.igraph()が呼び出される。
```

```{r}
# igraphオブジェクト
g
```

```{r}
# 頂点の数
vcount(g)

# 辺の数
ecount(g)
```

```{r}
# このグラフの頂点集合
V(g)

# このグラフの辺集合
E(g)
```

## グラフの可視化

`plot(g, vertex.size, vertex.color, vertex.label, vertex.label.cex, edge.color, edge.width, edge.label, layout)`

（Rには"generic"と呼ばれる仕組みがあり、実際にはplot.igraph()関数が呼び出されている。）

-   g： igraphオブジェクト

-   頂点に関する主要なパラメータ

    -   vertex.size：頂点の大きさ。デフォルト15

    -   vertex.color：頂点の色

    -   vertex.label：頂点のラベル

    -   vertex.label.cex：頂点のラベルの大きさ

    -   vertex.frame.width：頂点の枠の太さ

    -   vertex.frame.color：頂点の枠の色

-   辺に関する主要なパラメータ

    -   edge.color：辺の色

    -   edge.width：辺の太さ

    -   edge.label：辺のラベル

-   layout：グラフの配置（後で説明）

```{r}
set.seed(1234)
plot(g)

set.seed(1234)
plot(g, vertex.color="skyblue",vertex.label.color="black",vertex.label.cex=0.7,vertex.frame.color=NA)
```

### グラフの配置

igraphには、様々なグラフ配置アルゴリズムが実装されており、layout\_\*\*\*()という関数で利用できる。代表的なものをいくつか挙げると、

`layout_with_fr()`：Fruchterman-Reingold配置アルゴリズム

`layout_with_kk()`：Kamada-Kawai配置アルゴリズム

`layout_in_circle()`：円環上に配置

`layout_as_tree()`：ツリー状に配置

また、デフォルトで利用されているのは`layout_nicely()`で、これは比較的小さなグラフではFruchterman-Reingold配置アルゴリズム、大きなグラフでは`layout_with_drl()`が利用されるが、`layout_with_drl()`は大きなグラフに対して遅いようなので、`layout_with_fr()`を使った方がよいかも

```{r}
set.seed(1234)
plot(g, main="default") # デフォルトでlayout_nicelyが使われている。

set.seed(1234)
l=layout_with_fr(g) # Fruchterman-Reingold配置アルゴリズム
plot(g,layout=l, main="Fruchterman-Reingold")

set.seed(1234)
l=layout_with_kk(g) # Kamada-Kawai配置アルゴリズム
plot(g,layout=l, main="Kamada-Kawai")

set.seed(1234)
l=layout_in_circle(g) # 円環上に配置
plot(g,layout=l, main="circle")

set.seed(1234)
l=layout_as_tree(g) # ツリー状に配置
plot(g,layout=l, main="tree")

set.seed(1234)
l=layout_with_drl(g) # DrL配置アルゴリズム
plot(g,layout=l, main="drl")
```

## グラフの作成

### 隣接行列からグラフを作成

`graph_from_adjacency_matrix(adjmatrix, mode = c("directed", "undirected"), weighted = NULL)`

-   adjmatrix：隣接行列

-   mode：無向グラフなら"undirected"、有向グラフなら"directed"

-   weighted: 重み付きグラフを作りたいときはTRUEに

```{r}
# デフォルトでは有向グラフ
adj <- matrix(c(0,1,1,0,0,1,0,0,0),nrow=3)
print("有向グラフ")
print(adj)
g <- graph_from_adjacency_matrix(adj)
set.seed(1234)
plot(g, main="有向グラフ")

# 無向グラフの時は、mode="undirected"
adj <- matrix(c(0,1,1,1,0,1,1,1,0),nrow=3)
print("無向グラフ")
print(adj)
g <- graph_from_adjacency_matrix(adj,mode="undirected")
set.seed(1234)
plot(g, main="無向グラフ")

# weightedを指定しないと、重み付き隣接行列を与えても辺の数自体が増える
adj <- matrix(c(0,2,1,2,0,3,1,3,0),nrow=3)
print("重み付き無向グラフ")
print(adj)
g <- graph_from_adjacency_matrix(adj,mode="undirected")
set.seed(1234)
plot(g,main="weighted未指定")

# weightedを指定すると、重み付き隣接行列から重み付きグラフが作られるが、デフォルトのプロットでは重みは表示されない。
g <- graph_from_adjacency_matrix(adj,mode="undirected",weighted=T)
set.seed(1234)
plot(g,main="weighted=TRUE")

# グラフの辺集合のweightをedge.labelに指定
set.seed(1234)
plot(g, edge.label = E(g)$weight,main="辺に重みを表示")
```

### 辺リスト（edge list）からグラフを作成

授業では紹介しませんでしたが、Web上のネットワークデータの中には辺リストとしてデータが与えられているものも多いようなので紹介します。

-   辺リスト（各行が辺に対応する2列の行列。値は頂点の番号や名前を表す。）

```{r}
# さっきのグラフ
g <- make_graph("Zachary") # Zacharyの空手クラブの友人ネットワーク
set.seed(1234)
plot(g)

# このグラフから辺リストを取得
el <- as_edgelist(g)
print(el)
```

`graph_from_edgelist(el, directed = TRUE)`

-   el：辺リスト

-   directed：無向グラフの場合はFALSEに

なお、辺リストからは直接重み付きグラフを作ることはできず、グラフを作ってから重みを設定するようです。

```{r}
# 辺リストからグラフを作るとデフォルトでは有向グラフ
g <- graph_from_edgelist(el)
set.seed(1234)
plot(g)

# 辺リストから無向グラフを作る
g <- graph_from_edgelist(el,directed = F)
set.seed(1234)
plot(g)
```

#### KONECTのZebraネットワークの辺リストを読み込む

<http://konect.cc/networks/moreno_zebra/>

```{r}
el <- read.table("out.moreno_zebra_zebra", comment.char = "%")
print(el)

g <- graph_from_edgelist(as.matrix(el),directed = F)

# こちらでもよい
# g <- graph_from_data_frame(el,directed = F)

set.seed(1234)
plot(g)
```

#### Network Repositoryのaves-barn-swallow-contact-networkネットワークの辺リストを読み込む

<https://networkrepository.com/aves-barn-swallow-contact-network.php>

```{r}
el <- read.table("aves-barn-swallow-contact-network.edges", comment.char = "%", col.names=c("from", "to", "weight"))
# 3行目は重み
print(el)

g <- graph_from_data_frame(el,directed = F)
set.seed(1234)
plot(g,edge.label = E(g)$weight)
```

#### SNAP Datasetsのego-Facebookネットワークの辺リストを読み込む

<https://snap.stanford.edu/data/ego-Facebook.html>

```{r}
el <- read.table("facebook_combined.txt", comment.char = "%")
print(el)

g <- graph_from_data_frame(el,directed = F)

set.seed(1234)
plot(g,vertex.size=1, vertex.label=NA, edge.width=0.1,vertex.frame.width=0.1,)
```

### ネットワークの生成モデル

グラフ理論では、確率的なモデルを使って特定の性質を持つグラフを生成する手法が提案されている。詳細は、参考書「ネットワーク分析」などを参照してください。

#### Erdos-Renyi model（一番シンプルなランダムグラフ）

`sample_gnp(n, p, directed = FALSE)`

-   頂点数n, 頂点間に辺がある確率pのランダムグラフを作成する。

-   directed：有向グラフを作りたいときはTRUE

```{r}
set.seed(1234)
g <- sample_gnp(100,0.1)
plot(g,vertex.size=5, vertex.label=NA, edge.width=0.1, main="n=100")

set.seed(1234)
g <- sample_gnp(1000,0.01)
layout <- layout_with_fr(g)
plot(g,vertex.size=2, vertex.label=NA, edge.width=0.1, layout=layout,vertex.frame.width=0.1, main="n=1,000")

set.seed(1234)
g <- sample_gnp(10000,0.001)
layout <- layout_with_fr(g)
plot(g,vertex.size=1, vertex.label=NA, edge.width=0.1, layout=layout,vertex.frame.width=0.1, main="n=10,000")
```

#### Watts-Strogatz model（スモールワールドネットワークのモデル）

異なるコミュニティに属する頂点が、わずかな辺を介して繋がっている。

`sample_smallworld(dim, size, nei, p)`

-   dim：整数。

-   size：整数。頂点数は、sizeのdim乗になる。

-   nei：整数。隣接する頂点(neighborhood)の数

-   p：辺の付け替え確率

```{r}
set.seed(1234)
g <- sample_smallworld(dim=1,size=100,nei=2,p=0.1)
layout <- layout_with_fr(g)
plot(g,vertex.size=5, vertex.label=NA, edge.width=0.1,layout=layout, main="n=100")

set.seed(1234)
g <- sample_smallworld(dim=2,size=30,nei=1,p=0.1)
layout <- layout_with_fr(g)
plot(g,vertex.size=2, vertex.label=NA, edge.width=0.1, layout=layout,vertex.frame.width=0.1, main="n=900")
```

#### Scale Free Network (Barabasi-Abert model/Price model)

次数分布がべき乗則に従う。人気者がより人気者になるタイプのネットワーク

`sample_pa(n, power = 1, directed = TRUE)`

-   n：整数。頂点の数

-   power：ハブとなる頂点への集中の度合い

```{r}
set.seed(1234)
g <- sample_pa(n=100,power=1,directed=F)
plot(g,vertex.size=5, vertex.label=NA, edge.width=0.1, main="n=100")

set.seed(1234)
g <- sample_pa(n=100,power=1.5)
plot(g,vertex.size=5, vertex.label=NA, edge.width=0.1,edge.arrow.size=0.1, main="n=100")

set.seed(1234)
g <- sample_pa(n=1000,power=1.1,directed=F)
layout <- layout_with_fr(g)
plot(g,vertex.size=2, vertex.label=NA, edge.width=0.1, layout=layout,vertex.frame.width=0.1,edge.arrow.size=0.05, main="n=1,000")

set.seed(1234)
g <- sample_pa(n=10000,power=1.1,directed=F)
layout <- layout_with_fr(g)
plot(g,vertex.size=1, vertex.label=NA, edge.width=0.1, layout=layout,vertex.frame.width=0.1,edge.arrow.size=0.05, main="n=10,000")
```

## 相関ネットワーク

```{r}
# ここでは、irisデータを使う
iris

# irisデータ全体の特徴量間の相関行列
rho <- cor(iris[,-5])

# 隣接行列を作成
a <- rho>0.5 # 相関係数が0.5以上を残す。
diag(a) <- 0 # 対角要素を0に

# 隣接行列からグラフを作成
g <- graph_from_adjacency_matrix(a, mode = c("undirected"))
set.seed(1234)
plot(g)

# setosa種の特徴量間の相関ネットワーク
rho <- cor(iris[iris$Species=="setosa",-5])
a <- rho>0.5
diag(a) <- 0
g <- graph_from_adjacency_matrix(a, mode = c("undirected"))
set.seed(1234)
plot(g, main="setosa種")

# versicolor種の特徴量間の相関ネットワーク
rho <- cor(iris[iris$Species=="versicolor",-5])
a <- rho>0.5
diag(a) <- 0
g <- graph_from_adjacency_matrix(a, mode = c("undirected"))
set.seed(1234)
plot(g,main="versicolor種")

# virginica種の特徴量間の相関ネットワーク
rho <- cor(iris[iris$Species=="virginica",-5])
a <- rho>0.5
diag(a) <- 0
g <- graph_from_adjacency_matrix(a, mode = c("undirected"))
set.seed(1234)
plot(g,main="virginica種")
```

## 中心性指標

### 次数中心性

`degree(g)`

```{r}
g <- make_graph("Zachary") # 最初に使ったグラフ
degree(g)
set.seed(1234)
plot(g,vertex.size=degree(g))
```

### 媒介中心性

`betweenness(g)`

```{r}
betweenness(g)

# 特定のノードの媒介中心性が極端に大きく、可視化としてはうまくいかない。
set.seed(1234)
plot(g,vertex.size=betweenness(g))

# 例えば、対数変換してみた例
set.seed(1234)
plot(g,vertex.size=log(betweenness(g)+1))
```

### 辺に対する媒介中心性

`edge_betweenness(g)`

```{r message=FALSE}
#edge_betweenness(g)

set.seed(1234)
plot(g,edge.size=1)
set.seed(1234)
plot(g,edge.width=log(edge_betweenness(g)+1))
```

## コミュニティ検出

### Q値の直接最大化によるコミュニティ検出

`cluster_optimal(g)`

計算量が大きすぎるため、実際に利用可能なのはサイズの小さいグラフに限る。

```{r}
res <- cluster_optimal(g)

# 選ばれたコミュニティ構造のモジュラリティ指標
modularity(g, res$membership)

# igraphの機能に任せたコミュニティ分割の可視化
# "generic"の機能により、plot.igraph()ではなくplot.communities()が呼び出される。
set.seed(1234)
plot(res,g)

# 手動でのコミュニティ分割の可視化
set.seed(1234)
plot(g,vertex.color=res$membership)
```

### 媒介中心性を利用したコミュニティ検出

`cluster_edge_betweenness(g)`

\# igraphの機能に任せたコミュニティ分割の可視化

set.seed(1234)

plot(res,g)

```{r}
res <- cluster_edge_betweenness(g)

# 選ばれたコミュニティ構造のモジュラリティ指標
modularity(g, res$membership)

# 分割されていく過程のデンドログラム
plot(as.dendrogram(res))

# 分割過程のモジュラリティ指標
plot(res$modularity)

# 選ばれたコミュニティ分割
set.seed(1234)
plot(res,g)
```

### Louvain法

`cluster_louvain(g)`

```{r}
res <- cluster_louvain(g)

# 選ばれたコミュニティ構造のモジュラリティ指標
modularity(g, res$membership)

# 選ばれたコミュニティ分割
set.seed(1234)
plot(res,g)
```

### Leiden法

`cluster_leiden(g)`

```{r}
res <- cluster_leiden(g)

# 選ばれたコミュニティ構造のモジュラリティ指標（デフォルトのパラメータではなぜかうまくいっていない）
modularity(g, res$membership)

# 選ばれたコミュニティ分割
set.seed(1234)
plot(res,g)
```

```{r}
# コミュニティ分割（resolutionパラメータを調整）
res <- cluster_leiden(g, resolution=0.1)
set.seed(1234)
plot(g,vertex.color=res$membership)

# 選ばれたコミュニティ構造のモジュラリティ指標
modularity(g, res$membership)

# 選ばれたコミュニティ分割
set.seed(1234)
plot(res,g)
```
